name: Build & Deploy to ECS

on:
  push:
    branches: [ "master" ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Build JAR
      run: mvn clean package -DskipTests

    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build & Push Docker Image
      id: build-image
      run: |
        REPOSITORY_URI=336449586386.dkr.ecr.us-east-1.amazonaws.com
        IMAGE_TAG=${{ github.sha }}
        
        # Build and push using the SHA tag to ensure uniqueness
        docker build -t $REPOSITORY_URI:$IMAGE_TAG -t $REPOSITORY_URI:latest .
        docker push $REPOSITORY_URI:$IMAGE_TAG
        docker push $REPOSITORY_URI:latest
        
        echo "image=$REPOSITORY_URI:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Execute Deployment Script
      run: |
          REGION=us-east-1
          CLUSTER=health-api-cluster
          SERVICE_NAME=health-api-service
          IMAGE_URI=${{ steps.build-image.outputs.image }}
          
          # 1. Update JSON with the specific Image URI pushed above
          # Added [0] to correctly target the first container in the array
          jq --arg IMG "$IMAGE_URI" '.containerDefinitions[0].image = $IMG' task-definition.json > final-taskdef.json
          
          # 2. Register the task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition --cli-input-json file://final-taskdef.json --region ${REGION})
          REVISION=$(echo $NEW_TASK_INFO | jq -r .taskDefinition.revision)
          FAMILY=$(echo $NEW_TASK_INFO | jq -r .taskDefinition.family)
          
          # 3. Check if service exists
          SERVICE_EXISTS=$(aws ecs describe-services --services ${SERVICE_NAME} --cluster ${CLUSTER} --region ${REGION} | jq -r '.services | length')
          
          if [ "$SERVICE_EXISTS" -gt "0" ]; then
            echo "Updating existing service to revision $REVISION..."
            aws ecs update-service --cluster ${CLUSTER} --region ${REGION} --service ${SERVICE_NAME} --task-definition ${FAMILY}:${REVISION}
          else
            echo "Creating new EC2 service..."
            
            # 4. Get VPC ID (ensures subnets are all from the same VPC)
            VPC_ID=$(aws ec2 describe-subnets --region ${REGION} --query 'Subnets[0].VpcId' --output text)
            
            # 5. Get Subnets and Security Group for that VPC
            SUBNETS=$(aws ec2 describe-subnets --region ${REGION} --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output text | sed 's/\t/,/g')
            SEC_GROUP=$(aws ec2 describe-security-groups --region ${REGION} --filters "Name=vpc-id,Values=$VPC_ID" "Name=group-name,Values=default" --query 'SecurityGroups[0].GroupId' --output text)
            
            aws ecs create-service \
              --service-name ${SERVICE_NAME} \
              --cluster ${CLUSTER} \
              --region ${REGION} \
              --task-definition ${FAMILY}:${REVISION} \
              --launch-type EC2 \
              --desired-count 1 \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SEC_GROUP],assignPublicIp=DISABLED}"
          fi
